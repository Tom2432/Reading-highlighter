// ==UserScript==
// @name         Reading Assistant Highlighter
// @match        https://*/*
// @grant        none
// @version      1.0
// @author       Lee pal 
// @description  Highlights keywords on pages and shows tooltip definitions; download highlighted terms; toggle highlights on/off.
// ==/UserScript==

(function () {
  'use strict';

  /***************************************************************************
   * ----------------------------- CONFIGURATION ----------------------------- *
   * Edit top-level variables to control behaviour.
   ***************************************************************************/

  // Master toggle for the highlighter feature
  const enableHighlighter = true;

  // Keywords to highlight (provide at least 6 samples)
  const keywords = [
    'algorithm',
    'asynchronous',
    'closure',
    'polymorphism',
    'recursion',
    'encapsulation'
  ];

  // CSS applied to each highlighted <span>; keep it a string
  const highlightStyle = `
    background: linear-gradient(90deg, rgba(255,235,59,0.18), rgba(129,199,132,0.08));
    border-radius: 3px;
    padding: 0 2px;
    box-shadow: 0 1px 0 rgba(0,0,0,0.06) inset;
    cursor: help;
  `;

  // Tooltip feature toggle
  const enableTooltips = true;

  // Small dictionary used for tooltips (sample mappings)
  const tooltipDictionary = {
    'algorithm': 'A step-by-step procedure for calculations or problem-solving.',
    'asynchronous': 'Operations that occur independently of the main program flow.',
    'closure': 'A function bundled with its lexical environment.',
    'polymorphism': 'The ability of code to take multiple forms (OOP concept).',
    'recursion': 'A technique where a function calls itself.',
    'encapsulation': 'Hiding internal state and requiring all interaction through an interface.'
  };

  /***************************************************************************
   * --------------------------------- STATE --------------------------------
   ***************************************************************************/

  // Data attribute used to mark highlights created by this script
  const HIGHLIGHT_ATTR = 'data-ux-highlight';

  // Live references for controls and tooltip
  let tooltipEl = null;
  let controlPanelEl = null;

  /***************************************************************************
   * ------------------------------ UTIL FUNCTIONS ---------------------------
   ***************************************************************************/

  const log = (msg) => console.log('[ReadingAssistant]', msg);

  const escapeForRegex = (str) =>
    str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

  // Build combined regex for all keywords: use word boundaries where possible,
  // but allow matching inside hyphenated/compound words (we'll use \b when possible).
  const buildKeywordsRegex = (keys) => {
    const parts = keys
      .filter(Boolean)
      .map((k) => escapeForRegex(k));
    if (parts.length === 0) return null;
    // Use case-insensitive global search; prefer whole-word boundaries where possible
    // We use lookarounds to try to ensure we don't match inside HTML entities etc.
    return new RegExp(`\\b(${parts.join('|')})\\b`, 'gi');
  };

  const KW_REGEX = buildKeywordsRegex(keywords);

  // Return true when a node should be skipped from walking (inputs, scripts, styles, etc.)
  const shouldSkipNode = (node) => {
    if (!node) return true;
    if (node.nodeType !== Node.ELEMENT_NODE) return false;
    const tag = node.tagName.toLowerCase();
    const skipTags = ['script', 'style', 'noscript', 'iframe', 'canvas', 'svg'];
    if (skipTags.includes(tag)) return true;
    // Skip form controls and editable areas
    if (['input', 'textarea', 'select', 'button'].includes(tag)) return true;
    if (node.isContentEditable) return true;
    // Skip areas already generated by the script (control panel)
    if (node.hasAttribute && node.hasAttribute(HIGHLIGHT_ATTR + '-container')) return true;
    return false;
  };

  /***************************************************************************
   * --------------------------- TEXT-NODE WALKER ----------------------------
   * Walk the DOM, find text nodes, and replace matched keywords with <span>.
   * We take care not to break forms or links (we do not remove nodes inside
   * inputs/selects/textareas or contentEditable).
   ***************************************************************************/

  /**
   * Walk the document body and collect text nodes to process.
   * Skips elements that should not be scanned.
   */
  const collectTextNodes = (root = document.body) => {
    const walker = document.createTreeWalker(
      root,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: (node) => {
          const parent = node.parentNode;
          if (!parent) return NodeFilter.FILTER_REJECT;
          if (shouldSkipNode(parent)) return NodeFilter.FILTER_REJECT;
          // avoid very short or whitespace-only nodes
          if (!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
          // Avoid nodes already inside our highlights
          if (parent.closest && parent.closest(`[${HIGHLIGHT_ATTR}]`)) return NodeFilter.FILTER_REJECT;
          return NodeFilter.FILTER_ACCEPT;
        }
      },
      false
    );

    const nodes = [];
    while (walker.nextNode()) {
      nodes.push(walker.currentNode);
    }
    return nodes;
  };

  /**
   * Replace a text node by splitting and inserting spans for matched keywords.
   * Preserves original casing and surrounding text.
   */
  const highlightTextNode = (textNode, regex) => {
    const text = textNode.nodeValue;
    let match;
    let lastIndex = 0;
    const frag = document.createDocumentFragment();

    regex.lastIndex = 0;
    while ((match = regex.exec(text)) !== null) {
      const matchedText = match[0];
      const start = match.index;
      // Append preceding text
      if (start > lastIndex) {
        frag.appendChild(document.createTextNode(text.slice(lastIndex, start)));
      }

      // Create highlight span
      const span = document.createElement('span');
      span.setAttribute(HIGHLIGHT_ATTR, '1');
      // store original term for download/export
      span.setAttribute('data-ux-term', matchedText);
      span.setAttribute('tabindex', '-1'); // allow programmatic focus if needed
      span.setAttribute('role', 'button'); // hint for assistive tech that it's interactive
      span.style.cssText = highlightStyle;
      span.textContent = matchedText;

      // If tooltips enabled, attach events later (we'll use event delegation)
      frag.appendChild(span);

      lastIndex = start + matchedText.length;
    }

    // Append remaining text
    if (lastIndex < text.length) {
      frag.appendChild(document.createTextNode(text.slice(lastIndex)));
    }

    // Replace in DOM only if we created highlighted pieces
    if (frag.childNodes.length > 0) {
      textNode.parentNode.replaceChild(frag, textNode);
      return true;
    }
    return false;
  };

  /**
   * Run the highlighter across the document.
   * Returns number of highlights created.
   */
  const runHighlighter = () => {
    if (!KW_REGEX) {
      log('No keywords configured.');
      return 0;
    }
    const nodes = collectTextNodes();
    let created = 0;
    nodes.forEach((tn) => {
      try {
        const made = highlightTextNode(tn, KW_REGEX);
        if (made) created++;
      } catch (e) {
        // If regex fails or DOM mutation problem occurs, skip and continue
        console.warn('[ReadingAssistant] highlight error', e);
      }
    });
    // After creating spans, enable tooltip delegation
    if (enableTooltips && created > 0) {
      attachTooltipDelegation();
    }
    log(`Highlighter created highlights in ${created} text nodes.`);
    return created;
  };

  /**
   * Remove all highlights previously added by this script.
   * Restores their text nodes (i.e., removes <span data-ux-highlight> elements).
   */
  const removeHighlights = () => {
    const spans = Array.from(document.querySelectorAll(`span[${HIGHLIGHT_ATTR}]`));
    spans.forEach((span) => {
      const txt = document.createTextNode(span.textContent);
      span.parentNode.replaceChild(txt, span);
    });
    log(`Removed ${spans.length} highlight elements.`);
  };

  /***************************************************************************
   * ------------------------------ TOOLTIP LOGIC ----------------------------
   * Use event delegation: listen for mouseenter/leave on document and show a
   * small tooltip near cursor with definition or "No definition".
   ***************************************************************************/

  const createTooltipElement = () => {
    if (tooltipEl) return tooltipEl;
    const el = document.createElement('div');
    el.id = 'reading-assistant-tooltip';
    el.style.position = 'fixed';
    el.style.zIndex = '2147483647';
    el.style.pointerEvents = 'none';
    el.style.background = 'rgba(0,0,0,0.85)';
    el.style.color = 'white';
    el.style.padding = '6px 8px';
    el.style.borderRadius = '6px';
    el.style.fontSize = '12px';
    el.style.maxWidth = '320px';
    el.style.boxShadow = '0 8px 24px rgba(0,0,0,0.6)';
    el.style.transition = 'transform 120ms ease, opacity 120ms ease';
    el.style.transform = 'translateY(6px)';
    el.style.opacity = '0';
    el.style.whiteSpace = 'pre-wrap';
    el.style.lineHeight = '1.2';
    document.body.appendChild(el);
    tooltipEl = el;
    return el;
  };

  let currentHighlightedElement = null;

  const showTooltip = (targetEl, clientX, clientY) => {
    const el = createTooltipElement();
    const term = (targetEl && targetEl.getAttribute && targetEl.getAttribute('data-ux-term')) || targetEl.textContent;
    const keyLower = term ? term.toLowerCase() : '';
    const def = tooltipDictionary && tooltipDictionary[keyLower] || tooltipDictionary && tooltipDictionary[term] || null;
    const text = def ? def : 'No definition';
    el.textContent = `${term}: ${text}`;
    // Position: avoid going off-screen
    const margin = 12;
    const rect = el.getBoundingClientRect();
    let left = clientX + 14;
    let top = clientY + 14;
    // If near right edge, shift left
    if (left + rect.width + margin > window.innerWidth) {
      left = clientX - rect.width - 18;
    }
    if (top + rect.height + margin > window.innerHeight) {
      top = clientY - rect.height - 18;
    }
    el.style.left = `${Math.max(margin, left)}px`;
    el.style.top = `${Math.max(margin, top)}px`;
    requestAnimationFrame(() => {
      el.style.transform = 'translateY(0)';
      el.style.opacity = '1';
    });
    currentHighlightedElement = targetEl;
  };

  const hideTooltip = () => {
    if (!tooltipEl) return;
    tooltipEl.style.transform = 'translateY(6px)';
    tooltipEl.style.opacity = '0';
    currentHighlightedElement = null;
  };

  // Event delegation: mouseover/mouseout and mousemove to position tooltip near cursor
  let mouseMoveHandler = null;

  const attachTooltipDelegation = () => {
    // Avoid multiple attachments
    if (document._readingAssistantTooltipAttached) return;
    document._readingAssistantTooltipAttached = true;

    document.addEventListener('mouseover', (e) => {
      const target = e.target;
      if (target && target.getAttribute && target.getAttribute(HIGHLIGHT_ATTR)) {
        if (!enableTooltips) return;
        // Show tooltip using mouse position (from event)
        showTooltip(target, e.clientX, e.clientY);

        // Track mouse move to reposition tooltip
        mouseMoveHandler = (mv) => {
          if (!currentHighlightedElement) return;
          showTooltip(currentHighlightedElement, mv.clientX, mv.clientY);
        };
        document.addEventListener('mousemove', mouseMoveHandler);
      }
    });

    document.addEventListener('mouseout', (e) => {
      const target = e.target;
      if (target && target.getAttribute && target.getAttribute(HIGHLIGHT_ATTR)) {
        hideTooltip();
        if (mouseMoveHandler) {
          document.removeEventListener('mousemove', mouseMoveHandler);
          mouseMoveHandler = null;
        }
      }
    });

    // Also hide tooltip when scrolling or resizing to avoid misplaced tooltip
    window.addEventListener('scroll', hideTooltip, true);
    window.addEventListener('resize', hideTooltip);
  };

  /***************************************************************************
   * ------------------------ CONTROL PANEL & DOWNLOAD -----------------------
   * Provides a small UI button to toggle highlights and download JSON of
   * highlighted terms (term -> count).
   ***************************************************************************/

  const createControlPanel = () => {
    if (controlPanelEl) return controlPanelEl;
    const panel = document.createElement('div');
    panel.setAttribute(HIGHLIGHT_ATTR + '-container', '1');
    panel.style.position = 'fixed';
    panel.style.left = '12px';
    panel.style.bottom = '12px';
    panel.style.zIndex = '2147483647';
    panel.style.display = 'flex';
    panel.style.gap = '8px';
    panel.style.alignItems = 'center';
    panel.style.fontFamily = 'system-ui, -apple-system, "Segoe UI", Roboto, Arial';
    panel.style.fontSize = '13px';

    // Toggle button
    const toggleBtn = document.createElement('button');
    toggleBtn.type = 'button';
    toggleBtn.textContent = 'Toggle Highlights';
    toggleBtn.setAttribute('aria-pressed', 'false');
    toggleBtn.style.padding = '8px 10px';
    toggleBtn.style.borderRadius = '8px';
    toggleBtn.style.border = 'none';
    toggleBtn.style.background = 'rgba(0,0,0,0.7)';
    toggleBtn.style.color = '#fff';
    toggleBtn.style.cursor = 'pointer';
    toggleBtn.addEventListener('click', () => {
      const any = document.querySelector(`span[${HIGHLIGHT_ATTR}]`);
      if (any) {
        removeHighlights();
        toggleBtn.setAttribute('aria-pressed', 'false');
        toggleBtn.textContent = 'Enable Highlights';
      } else {
        runHighlighter();
        toggleBtn.setAttribute('aria-pressed', 'true');
        toggleBtn.textContent = 'Disable Highlights';
      }
    });

    // Download button
    const downloadBtn = document.createElement('button');
    downloadBtn.type = 'button';
    downloadBtn.textContent = 'Download Highlights';
    downloadBtn.style.padding = '8px 10px';
    downloadBtn.style.borderRadius = '8px';
    downloadBtn.style.border = 'none';
    downloadBtn.style.background = 'rgba(255,255,255,0.92)';
    downloadBtn.style.color = '#111';
    downloadBtn.style.cursor = 'pointer';
    downloadBtn.addEventListener('click', () => {
      const terms = Array.from(document.querySelectorAll(`span[${HIGHLIGHT_ATTR}]`))
        .map((s) => s.getAttribute('data-ux-term') || s.textContent);
      const summary = terms.reduce((acc, t) => {
        const key = t;
        acc[key] = (acc[key] || 0) + 1;
        return acc;
      }, {});
      const payload = {
        url: window.location.href,
        timestamp: new Date().toISOString(),
        summary
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `highlights-${(new Date()).toISOString().slice(0,19).replace(/[:T]/g,'-')}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      log('Downloaded highlighted terms JSON.');
    });

    // Style adjustments for accessibility (focus outlines)
    [toggleBtn, downloadBtn].forEach((b) => {
      b.addEventListener('focus', () => {
        b.style.outline = '3px solid rgba(127,183,255,0.18)';
        b.style.outlineOffset = '2px';
      });
      b.addEventListener('blur', () => {
        b.style.outline = 'none';
      });
    });

    panel.appendChild(toggleBtn);
    panel.appendChild(downloadBtn);

    document.body.appendChild(panel);
    controlPanelEl = panel;
    return panel;
  };

  /***************************************************************************
   * --------------------------------- INIT ---------------------------------
   ***************************************************************************/

  const initialize = () => {
    if (!enableHighlighter) {
      log('Highlighter disabled via config.');
      return;
    }
    // Build initial tooltip and control panel
    if (enableTooltips) createTooltipElement();
    createControlPanel();

    // Run highlighter immediately
    runHighlighter();

    // Observe DOM changes to highlight dynamically added content
    const observer = new MutationObserver((mutations) => {
      // Basic heuristics: if new nodes added, try to run highlighter again
      let added = false;
      for (const m of mutations) {
        if (m.addedNodes && m.addedNodes.length > 0) {
          added = true;
          break;
        }
      }
      if (added) {
        // Debounce to avoid excessive work
        if (window._readingAssistantDebounce) {
          clearTimeout(window._readingAssistantDebounce);
        }
        window._readingAssistantDebounce = setTimeout(() => {
          runHighlighter();
        }, 350);
      }
    });

    observer.observe(document.body, { childList: true, subtree: true });

    log('Reading Assistant initialized.');
  };

  // Start once DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initialize);
  } else {
    initialize();
  }

  /***************************************************************************
   * ---------------------------- EXPORT (dev) -------------------------------
   * Expose simple API for debugging from console (optional)
   ***************************************************************************/
  try {
    window.ReadingAssistant = {
      runHighlighter,
      removeHighlights,
      collectTextNodes
    };
  } catch (e) {
    // ignore
  }
})();
